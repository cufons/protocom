// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pcomserver.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_pcomserver_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_pcomserver_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_util.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_pcomserver_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_pcomserver_2eproto {
  static const ::uint32_t offsets[];
};
class ClientAuthRequest;
struct ClientAuthRequestDefaultTypeInternal;
extern ClientAuthRequestDefaultTypeInternal _ClientAuthRequest_default_instance_;
class ClientConnectedStateRequest;
struct ClientConnectedStateRequestDefaultTypeInternal;
extern ClientConnectedStateRequestDefaultTypeInternal _ClientConnectedStateRequest_default_instance_;
class KexMsg;
struct KexMsgDefaultTypeInternal;
extern KexMsgDefaultTypeInternal _KexMsg_default_instance_;
class ServerAuthResponse;
struct ServerAuthResponseDefaultTypeInternal;
extern ServerAuthResponseDefaultTypeInternal _ServerAuthResponse_default_instance_;
class ServerConnectedStateResponse;
struct ServerConnectedStateResponseDefaultTypeInternal;
extern ServerConnectedStateResponseDefaultTypeInternal _ServerConnectedStateResponse_default_instance_;
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

enum KexMsg_KexAlg : int {
  KexMsg_KexAlg_KEX_UNKNOWN = 0,
  KexMsg_KexAlg_KEX_ECDH = 1,
  KexMsg_KexAlg_KexMsg_KexAlg_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  KexMsg_KexAlg_KexMsg_KexAlg_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool KexMsg_KexAlg_IsValid(int value);
extern const uint32_t KexMsg_KexAlg_internal_data_[];
constexpr KexMsg_KexAlg KexMsg_KexAlg_KexAlg_MIN = static_cast<KexMsg_KexAlg>(0);
constexpr KexMsg_KexAlg KexMsg_KexAlg_KexAlg_MAX = static_cast<KexMsg_KexAlg>(1);
constexpr int KexMsg_KexAlg_KexAlg_ARRAYSIZE = 1 + 1;
const std::string& KexMsg_KexAlg_Name(KexMsg_KexAlg value);
template <typename T>
const std::string& KexMsg_KexAlg_Name(T value) {
  static_assert(std::is_same<T, KexMsg_KexAlg>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to KexAlg_Name().");
  return KexMsg_KexAlg_Name(static_cast<KexMsg_KexAlg>(value));
}
const std::string& KexMsg_KexAlg_Name(KexMsg_KexAlg value);
bool KexMsg_KexAlg_Parse(absl::string_view name, KexMsg_KexAlg* value);
enum ClientConnectedStateRequest_RequestType : int {
  ClientConnectedStateRequest_RequestType_UNKNOWN = 0,
  ClientConnectedStateRequest_RequestType_REQUEST_KEX = 1,
  ClientConnectedStateRequest_RequestType_REQUEST_AUTH = 2,
  ClientConnectedStateRequest_RequestType_ClientConnectedStateRequest_RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ClientConnectedStateRequest_RequestType_ClientConnectedStateRequest_RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ClientConnectedStateRequest_RequestType_IsValid(int value);
extern const uint32_t ClientConnectedStateRequest_RequestType_internal_data_[];
constexpr ClientConnectedStateRequest_RequestType ClientConnectedStateRequest_RequestType_RequestType_MIN = static_cast<ClientConnectedStateRequest_RequestType>(0);
constexpr ClientConnectedStateRequest_RequestType ClientConnectedStateRequest_RequestType_RequestType_MAX = static_cast<ClientConnectedStateRequest_RequestType>(2);
constexpr int ClientConnectedStateRequest_RequestType_RequestType_ARRAYSIZE = 2 + 1;
const std::string& ClientConnectedStateRequest_RequestType_Name(ClientConnectedStateRequest_RequestType value);
template <typename T>
const std::string& ClientConnectedStateRequest_RequestType_Name(T value) {
  static_assert(std::is_same<T, ClientConnectedStateRequest_RequestType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RequestType_Name().");
  return ClientConnectedStateRequest_RequestType_Name(static_cast<ClientConnectedStateRequest_RequestType>(value));
}
const std::string& ClientConnectedStateRequest_RequestType_Name(ClientConnectedStateRequest_RequestType value);
bool ClientConnectedStateRequest_RequestType_Parse(absl::string_view name, ClientConnectedStateRequest_RequestType* value);
enum ServerConnectedStateResponse_ResponseStatus : int {
  ServerConnectedStateResponse_ResponseStatus_UNKNOWN = 0,
  ServerConnectedStateResponse_ResponseStatus_OK = 1,
  ServerConnectedStateResponse_ResponseStatus_INVALID_REQUEST = 2,
  ServerConnectedStateResponse_ResponseStatus_REQUEST_ERROR = 3,
  ServerConnectedStateResponse_ResponseStatus_DECODE_ERROR = 4,
  ServerConnectedStateResponse_ResponseStatus_AUTH_REQUIRED = 5,
  ServerConnectedStateResponse_ResponseStatus_ServerConnectedStateResponse_ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ServerConnectedStateResponse_ResponseStatus_ServerConnectedStateResponse_ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ServerConnectedStateResponse_ResponseStatus_IsValid(int value);
extern const uint32_t ServerConnectedStateResponse_ResponseStatus_internal_data_[];
constexpr ServerConnectedStateResponse_ResponseStatus ServerConnectedStateResponse_ResponseStatus_ResponseStatus_MIN = static_cast<ServerConnectedStateResponse_ResponseStatus>(0);
constexpr ServerConnectedStateResponse_ResponseStatus ServerConnectedStateResponse_ResponseStatus_ResponseStatus_MAX = static_cast<ServerConnectedStateResponse_ResponseStatus>(5);
constexpr int ServerConnectedStateResponse_ResponseStatus_ResponseStatus_ARRAYSIZE = 5 + 1;
const std::string& ServerConnectedStateResponse_ResponseStatus_Name(ServerConnectedStateResponse_ResponseStatus value);
template <typename T>
const std::string& ServerConnectedStateResponse_ResponseStatus_Name(T value) {
  static_assert(std::is_same<T, ServerConnectedStateResponse_ResponseStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseStatus_Name().");
  return ServerConnectedStateResponse_ResponseStatus_Name(static_cast<ServerConnectedStateResponse_ResponseStatus>(value));
}
const std::string& ServerConnectedStateResponse_ResponseStatus_Name(ServerConnectedStateResponse_ResponseStatus value);
bool ServerConnectedStateResponse_ResponseStatus_Parse(absl::string_view name, ServerConnectedStateResponse_ResponseStatus* value);
enum ClientAuthRequest_RequestType : int {
  ClientAuthRequest_RequestType_UNKNOWN = 0,
  ClientAuthRequest_RequestType_AUTH_SUPPLY = 1,
  ClientAuthRequest_RequestType_AUTH_INFO = 2,
  ClientAuthRequest_RequestType_ClientAuthRequest_RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ClientAuthRequest_RequestType_ClientAuthRequest_RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ClientAuthRequest_RequestType_IsValid(int value);
extern const uint32_t ClientAuthRequest_RequestType_internal_data_[];
constexpr ClientAuthRequest_RequestType ClientAuthRequest_RequestType_RequestType_MIN = static_cast<ClientAuthRequest_RequestType>(0);
constexpr ClientAuthRequest_RequestType ClientAuthRequest_RequestType_RequestType_MAX = static_cast<ClientAuthRequest_RequestType>(2);
constexpr int ClientAuthRequest_RequestType_RequestType_ARRAYSIZE = 2 + 1;
const std::string& ClientAuthRequest_RequestType_Name(ClientAuthRequest_RequestType value);
template <typename T>
const std::string& ClientAuthRequest_RequestType_Name(T value) {
  static_assert(std::is_same<T, ClientAuthRequest_RequestType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RequestType_Name().");
  return ClientAuthRequest_RequestType_Name(static_cast<ClientAuthRequest_RequestType>(value));
}
const std::string& ClientAuthRequest_RequestType_Name(ClientAuthRequest_RequestType value);
bool ClientAuthRequest_RequestType_Parse(absl::string_view name, ClientAuthRequest_RequestType* value);
enum ServerAuthResponse_ResponseStatus : int {
  ServerAuthResponse_ResponseStatus_UNKNOWN = 0,
  ServerAuthResponse_ResponseStatus_AUTH_ACCEPT = 1,
  ServerAuthResponse_ResponseStatus_AUTH_REJECT = 2,
  ServerAuthResponse_ResponseStatus_AUTH_CONTINUE = 3,
  ServerAuthResponse_ResponseStatus_INVALID_REQUEST = 4,
  ServerAuthResponse_ResponseStatus_DECODE_ERROR = 5,
  ServerAuthResponse_ResponseStatus_ServerAuthResponse_ResponseStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ServerAuthResponse_ResponseStatus_ServerAuthResponse_ResponseStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ServerAuthResponse_ResponseStatus_IsValid(int value);
extern const uint32_t ServerAuthResponse_ResponseStatus_internal_data_[];
constexpr ServerAuthResponse_ResponseStatus ServerAuthResponse_ResponseStatus_ResponseStatus_MIN = static_cast<ServerAuthResponse_ResponseStatus>(0);
constexpr ServerAuthResponse_ResponseStatus ServerAuthResponse_ResponseStatus_ResponseStatus_MAX = static_cast<ServerAuthResponse_ResponseStatus>(5);
constexpr int ServerAuthResponse_ResponseStatus_ResponseStatus_ARRAYSIZE = 5 + 1;
const std::string& ServerAuthResponse_ResponseStatus_Name(ServerAuthResponse_ResponseStatus value);
template <typename T>
const std::string& ServerAuthResponse_ResponseStatus_Name(T value) {
  static_assert(std::is_same<T, ServerAuthResponse_ResponseStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ResponseStatus_Name().");
  return ServerAuthResponse_ResponseStatus_Name(static_cast<ServerAuthResponse_ResponseStatus>(value));
}
const std::string& ServerAuthResponse_ResponseStatus_Name(ServerAuthResponse_ResponseStatus value);
bool ServerAuthResponse_ResponseStatus_Parse(absl::string_view name, ServerAuthResponse_ResponseStatus* value);
enum ServerAuthResponse_AuthMethod : int {
  ServerAuthResponse_AuthMethod_AUTH_UNKNOWN = 0,
  ServerAuthResponse_AuthMethod_AUTH_CHALLENGE = 1,
  ServerAuthResponse_AuthMethod_AUTH_KEY = 2,
  ServerAuthResponse_AuthMethod_ServerAuthResponse_AuthMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ServerAuthResponse_AuthMethod_ServerAuthResponse_AuthMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ServerAuthResponse_AuthMethod_IsValid(int value);
extern const uint32_t ServerAuthResponse_AuthMethod_internal_data_[];
constexpr ServerAuthResponse_AuthMethod ServerAuthResponse_AuthMethod_AuthMethod_MIN = static_cast<ServerAuthResponse_AuthMethod>(0);
constexpr ServerAuthResponse_AuthMethod ServerAuthResponse_AuthMethod_AuthMethod_MAX = static_cast<ServerAuthResponse_AuthMethod>(2);
constexpr int ServerAuthResponse_AuthMethod_AuthMethod_ARRAYSIZE = 2 + 1;
const std::string& ServerAuthResponse_AuthMethod_Name(ServerAuthResponse_AuthMethod value);
template <typename T>
const std::string& ServerAuthResponse_AuthMethod_Name(T value) {
  static_assert(std::is_same<T, ServerAuthResponse_AuthMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AuthMethod_Name().");
  return ServerAuthResponse_AuthMethod_Name(static_cast<ServerAuthResponse_AuthMethod>(value));
}
const std::string& ServerAuthResponse_AuthMethod_Name(ServerAuthResponse_AuthMethod value);
bool ServerAuthResponse_AuthMethod_Parse(absl::string_view name, ServerAuthResponse_AuthMethod* value);

// ===================================================================


// -------------------------------------------------------------------

class ServerAuthResponse final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ServerAuthResponse) */ {
 public:
  inline ServerAuthResponse() : ServerAuthResponse(nullptr) {}
  ~ServerAuthResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerAuthResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerAuthResponse(const ServerAuthResponse& from) : ServerAuthResponse(nullptr, from) {}
  inline ServerAuthResponse(ServerAuthResponse&& from) noexcept
      : ServerAuthResponse(nullptr, std::move(from)) {}
  inline ServerAuthResponse& operator=(const ServerAuthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerAuthResponse& operator=(ServerAuthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ServerAuthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerAuthResponse* internal_default_instance() {
    return reinterpret_cast<const ServerAuthResponse*>(
        &_ServerAuthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ServerAuthResponse& a, ServerAuthResponse& b) { a.Swap(&b); }
  inline void Swap(ServerAuthResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerAuthResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerAuthResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::MessageLite::DefaultConstruct<ServerAuthResponse>(arena);
  }
  void CheckTypeAndMergeFrom(
      const ::google::protobuf::MessageLite& from) final;
  void CopyFrom(const ServerAuthResponse& from);
  void MergeFrom(const ServerAuthResponse& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServerAuthResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ServerAuthResponse"; }

 protected:
  explicit ServerAuthResponse(::google::protobuf::Arena* arena);
  ServerAuthResponse(::google::protobuf::Arena* arena, const ServerAuthResponse& from);
  ServerAuthResponse(::google::protobuf::Arena* arena, ServerAuthResponse&& from) noexcept
      : ServerAuthResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  // nested types ----------------------------------------------------
  using ResponseStatus = ServerAuthResponse_ResponseStatus;
  static constexpr ResponseStatus UNKNOWN = ServerAuthResponse_ResponseStatus_UNKNOWN;
  static constexpr ResponseStatus AUTH_ACCEPT = ServerAuthResponse_ResponseStatus_AUTH_ACCEPT;
  static constexpr ResponseStatus AUTH_REJECT = ServerAuthResponse_ResponseStatus_AUTH_REJECT;
  static constexpr ResponseStatus AUTH_CONTINUE = ServerAuthResponse_ResponseStatus_AUTH_CONTINUE;
  static constexpr ResponseStatus INVALID_REQUEST = ServerAuthResponse_ResponseStatus_INVALID_REQUEST;
  static constexpr ResponseStatus DECODE_ERROR = ServerAuthResponse_ResponseStatus_DECODE_ERROR;
  static inline bool ResponseStatus_IsValid(int value) {
    return ServerAuthResponse_ResponseStatus_IsValid(value);
  }
  static constexpr ResponseStatus ResponseStatus_MIN = ServerAuthResponse_ResponseStatus_ResponseStatus_MIN;
  static constexpr ResponseStatus ResponseStatus_MAX = ServerAuthResponse_ResponseStatus_ResponseStatus_MAX;
  static constexpr int ResponseStatus_ARRAYSIZE = ServerAuthResponse_ResponseStatus_ResponseStatus_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ResponseStatus_Name(T value) {
    return ServerAuthResponse_ResponseStatus_Name(value);
  }
  static inline bool ResponseStatus_Parse(absl::string_view name, ResponseStatus* value) {
    return ServerAuthResponse_ResponseStatus_Parse(name, value);
  }
  using AuthMethod = ServerAuthResponse_AuthMethod;
  static constexpr AuthMethod AUTH_UNKNOWN = ServerAuthResponse_AuthMethod_AUTH_UNKNOWN;
  static constexpr AuthMethod AUTH_CHALLENGE = ServerAuthResponse_AuthMethod_AUTH_CHALLENGE;
  static constexpr AuthMethod AUTH_KEY = ServerAuthResponse_AuthMethod_AUTH_KEY;
  static inline bool AuthMethod_IsValid(int value) {
    return ServerAuthResponse_AuthMethod_IsValid(value);
  }
  static constexpr AuthMethod AuthMethod_MIN = ServerAuthResponse_AuthMethod_AuthMethod_MIN;
  static constexpr AuthMethod AuthMethod_MAX = ServerAuthResponse_AuthMethod_AuthMethod_MAX;
  static constexpr int AuthMethod_ARRAYSIZE = ServerAuthResponse_AuthMethod_AuthMethod_ARRAYSIZE;
  template <typename T>
  static inline const std::string& AuthMethod_Name(T value) {
    return ServerAuthResponse_AuthMethod_Name(value);
  }
  static inline bool AuthMethod_Parse(absl::string_view name, AuthMethod* value) {
    return ServerAuthResponse_AuthMethod_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMethodFieldNumber = 3,
    kServerInfoFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated .ServerAuthResponse.AuthMethod method = 3;
  int method_size() const;
  private:
  int _internal_method_size() const;

  public:
  void clear_method() ;
  public:
  ::ServerAuthResponse_AuthMethod method(int index) const;
  void set_method(int index, ::ServerAuthResponse_AuthMethod value);
  void add_method(::ServerAuthResponse_AuthMethod value);
  const ::google::protobuf::RepeatedField<int>& method() const;
  ::google::protobuf::RepeatedField<int>* mutable_method();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_method() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_method();

  public:
  // optional string serverInfo = 2;
  bool has_serverinfo() const;
  void clear_serverinfo() ;
  const std::string& serverinfo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_serverinfo(Arg_&& arg, Args_... args);
  std::string* mutable_serverinfo();
  PROTOBUF_NODISCARD std::string* release_serverinfo();
  void set_allocated_serverinfo(std::string* value);

  private:
  const std::string& _internal_serverinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serverinfo(
      const std::string& value);
  std::string* _internal_mutable_serverinfo();

  public:
  // .ServerAuthResponse.ResponseStatus status = 1;
  void clear_status() ;
  ::ServerAuthResponse_ResponseStatus status() const;
  void set_status(::ServerAuthResponse_ResponseStatus value);

  private:
  ::ServerAuthResponse_ResponseStatus _internal_status() const;
  void _internal_set_status(::ServerAuthResponse_ResponseStatus value);

  public:
  // @@protoc_insertion_point(class_scope:ServerAuthResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> method_;
    mutable ::google::protobuf::internal::CachedSize _method_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr serverinfo_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pcomserver_2eproto;
};
// -------------------------------------------------------------------

class KexMsg final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:KexMsg) */ {
 public:
  inline KexMsg() : KexMsg(nullptr) {}
  ~KexMsg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KexMsg(
      ::google::protobuf::internal::ConstantInitialized);

  inline KexMsg(const KexMsg& from) : KexMsg(nullptr, from) {}
  inline KexMsg(KexMsg&& from) noexcept
      : KexMsg(nullptr, std::move(from)) {}
  inline KexMsg& operator=(const KexMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline KexMsg& operator=(KexMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const KexMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const KexMsg* internal_default_instance() {
    return reinterpret_cast<const KexMsg*>(
        &_KexMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(KexMsg& a, KexMsg& b) { a.Swap(&b); }
  inline void Swap(KexMsg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KexMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KexMsg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::MessageLite::DefaultConstruct<KexMsg>(arena);
  }
  void CheckTypeAndMergeFrom(
      const ::google::protobuf::MessageLite& from) final;
  void CopyFrom(const KexMsg& from);
  void MergeFrom(const KexMsg& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KexMsg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "KexMsg"; }

 protected:
  explicit KexMsg(::google::protobuf::Arena* arena);
  KexMsg(::google::protobuf::Arena* arena, const KexMsg& from);
  KexMsg(::google::protobuf::Arena* arena, KexMsg&& from) noexcept
      : KexMsg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  // nested types ----------------------------------------------------
  using KexAlg = KexMsg_KexAlg;
  static constexpr KexAlg KEX_UNKNOWN = KexMsg_KexAlg_KEX_UNKNOWN;
  static constexpr KexAlg KEX_ECDH = KexMsg_KexAlg_KEX_ECDH;
  static inline bool KexAlg_IsValid(int value) {
    return KexMsg_KexAlg_IsValid(value);
  }
  static constexpr KexAlg KexAlg_MIN = KexMsg_KexAlg_KexAlg_MIN;
  static constexpr KexAlg KexAlg_MAX = KexMsg_KexAlg_KexAlg_MAX;
  static constexpr int KexAlg_ARRAYSIZE = KexMsg_KexAlg_KexAlg_ARRAYSIZE;
  template <typename T>
  static inline const std::string& KexAlg_Name(T value) {
    return KexMsg_KexAlg_Name(value);
  }
  static inline bool KexAlg_Parse(absl::string_view name, KexAlg* value) {
    return KexMsg_KexAlg_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kPkeyFieldNumber = 2,
    kAlgFieldNumber = 1,
  };
  // bytes pkey = 2;
  void clear_pkey() ;
  const std::string& pkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pkey(Arg_&& arg, Args_... args);
  std::string* mutable_pkey();
  PROTOBUF_NODISCARD std::string* release_pkey();
  void set_allocated_pkey(std::string* value);

  private:
  const std::string& _internal_pkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pkey(
      const std::string& value);
  std::string* _internal_mutable_pkey();

  public:
  // .KexMsg.KexAlg alg = 1;
  void clear_alg() ;
  ::KexMsg_KexAlg alg() const;
  void set_alg(::KexMsg_KexAlg value);

  private:
  ::KexMsg_KexAlg _internal_alg() const;
  void _internal_set_alg(::KexMsg_KexAlg value);

  public:
  // @@protoc_insertion_point(class_scope:KexMsg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr pkey_;
    int alg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pcomserver_2eproto;
};
// -------------------------------------------------------------------

class ClientAuthRequest final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ClientAuthRequest) */ {
 public:
  inline ClientAuthRequest() : ClientAuthRequest(nullptr) {}
  ~ClientAuthRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientAuthRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientAuthRequest(const ClientAuthRequest& from) : ClientAuthRequest(nullptr, from) {}
  inline ClientAuthRequest(ClientAuthRequest&& from) noexcept
      : ClientAuthRequest(nullptr, std::move(from)) {}
  inline ClientAuthRequest& operator=(const ClientAuthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientAuthRequest& operator=(ClientAuthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientAuthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientAuthRequest* internal_default_instance() {
    return reinterpret_cast<const ClientAuthRequest*>(
        &_ClientAuthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(ClientAuthRequest& a, ClientAuthRequest& b) { a.Swap(&b); }
  inline void Swap(ClientAuthRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientAuthRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientAuthRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::MessageLite::DefaultConstruct<ClientAuthRequest>(arena);
  }
  void CheckTypeAndMergeFrom(
      const ::google::protobuf::MessageLite& from) final;
  void CopyFrom(const ClientAuthRequest& from);
  void MergeFrom(const ClientAuthRequest& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClientAuthRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ClientAuthRequest"; }

 protected:
  explicit ClientAuthRequest(::google::protobuf::Arena* arena);
  ClientAuthRequest(::google::protobuf::Arena* arena, const ClientAuthRequest& from);
  ClientAuthRequest(::google::protobuf::Arena* arena, ClientAuthRequest&& from) noexcept
      : ClientAuthRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  // nested types ----------------------------------------------------
  using RequestType = ClientAuthRequest_RequestType;
  static constexpr RequestType UNKNOWN = ClientAuthRequest_RequestType_UNKNOWN;
  static constexpr RequestType AUTH_SUPPLY = ClientAuthRequest_RequestType_AUTH_SUPPLY;
  static constexpr RequestType AUTH_INFO = ClientAuthRequest_RequestType_AUTH_INFO;
  static inline bool RequestType_IsValid(int value) {
    return ClientAuthRequest_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN = ClientAuthRequest_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX = ClientAuthRequest_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE = ClientAuthRequest_RequestType_RequestType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& RequestType_Name(T value) {
    return ClientAuthRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(absl::string_view name, RequestType* value) {
    return ClientAuthRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kRequestFieldNumber = 1,
  };
  // .ClientAuthRequest.RequestType request = 1;
  void clear_request() ;
  ::ClientAuthRequest_RequestType request() const;
  void set_request(::ClientAuthRequest_RequestType value);

  private:
  ::ClientAuthRequest_RequestType _internal_request() const;
  void _internal_set_request(::ClientAuthRequest_RequestType value);

  public:
  // @@protoc_insertion_point(class_scope:ClientAuthRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    int request_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pcomserver_2eproto;
};
// -------------------------------------------------------------------

class ServerConnectedStateResponse final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ServerConnectedStateResponse) */ {
 public:
  inline ServerConnectedStateResponse() : ServerConnectedStateResponse(nullptr) {}
  ~ServerConnectedStateResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ServerConnectedStateResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ServerConnectedStateResponse(const ServerConnectedStateResponse& from) : ServerConnectedStateResponse(nullptr, from) {}
  inline ServerConnectedStateResponse(ServerConnectedStateResponse&& from) noexcept
      : ServerConnectedStateResponse(nullptr, std::move(from)) {}
  inline ServerConnectedStateResponse& operator=(const ServerConnectedStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerConnectedStateResponse& operator=(ServerConnectedStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ServerConnectedStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServerConnectedStateResponse* internal_default_instance() {
    return reinterpret_cast<const ServerConnectedStateResponse*>(
        &_ServerConnectedStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(ServerConnectedStateResponse& a, ServerConnectedStateResponse& b) { a.Swap(&b); }
  inline void Swap(ServerConnectedStateResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServerConnectedStateResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ServerConnectedStateResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::MessageLite::DefaultConstruct<ServerConnectedStateResponse>(arena);
  }
  void CheckTypeAndMergeFrom(
      const ::google::protobuf::MessageLite& from) final;
  void CopyFrom(const ServerConnectedStateResponse& from);
  void MergeFrom(const ServerConnectedStateResponse& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ServerConnectedStateResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ServerConnectedStateResponse"; }

 protected:
  explicit ServerConnectedStateResponse(::google::protobuf::Arena* arena);
  ServerConnectedStateResponse(::google::protobuf::Arena* arena, const ServerConnectedStateResponse& from);
  ServerConnectedStateResponse(::google::protobuf::Arena* arena, ServerConnectedStateResponse&& from) noexcept
      : ServerConnectedStateResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  // nested types ----------------------------------------------------
  using ResponseStatus = ServerConnectedStateResponse_ResponseStatus;
  static constexpr ResponseStatus UNKNOWN = ServerConnectedStateResponse_ResponseStatus_UNKNOWN;
  static constexpr ResponseStatus OK = ServerConnectedStateResponse_ResponseStatus_OK;
  static constexpr ResponseStatus INVALID_REQUEST = ServerConnectedStateResponse_ResponseStatus_INVALID_REQUEST;
  static constexpr ResponseStatus REQUEST_ERROR = ServerConnectedStateResponse_ResponseStatus_REQUEST_ERROR;
  static constexpr ResponseStatus DECODE_ERROR = ServerConnectedStateResponse_ResponseStatus_DECODE_ERROR;
  static constexpr ResponseStatus AUTH_REQUIRED = ServerConnectedStateResponse_ResponseStatus_AUTH_REQUIRED;
  static inline bool ResponseStatus_IsValid(int value) {
    return ServerConnectedStateResponse_ResponseStatus_IsValid(value);
  }
  static constexpr ResponseStatus ResponseStatus_MIN = ServerConnectedStateResponse_ResponseStatus_ResponseStatus_MIN;
  static constexpr ResponseStatus ResponseStatus_MAX = ServerConnectedStateResponse_ResponseStatus_ResponseStatus_MAX;
  static constexpr int ResponseStatus_ARRAYSIZE = ServerConnectedStateResponse_ResponseStatus_ResponseStatus_ARRAYSIZE;
  template <typename T>
  static inline const std::string& ResponseStatus_Name(T value) {
    return ServerConnectedStateResponse_ResponseStatus_Name(value);
  }
  static inline bool ResponseStatus_Parse(absl::string_view name, ResponseStatus* value) {
    return ServerConnectedStateResponse_ResponseStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kKexFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // optional .KexMsg kex = 2;
  bool has_kex() const;
  void clear_kex() ;
  const ::KexMsg& kex() const;
  PROTOBUF_NODISCARD ::KexMsg* release_kex();
  ::KexMsg* mutable_kex();
  void set_allocated_kex(::KexMsg* value);
  void unsafe_arena_set_allocated_kex(::KexMsg* value);
  ::KexMsg* unsafe_arena_release_kex();

  private:
  const ::KexMsg& _internal_kex() const;
  ::KexMsg* _internal_mutable_kex();

  public:
  // .ServerConnectedStateResponse.ResponseStatus status = 1;
  void clear_status() ;
  ::ServerConnectedStateResponse_ResponseStatus status() const;
  void set_status(::ServerConnectedStateResponse_ResponseStatus value);

  private:
  ::ServerConnectedStateResponse_ResponseStatus _internal_status() const;
  void _internal_set_status(::ServerConnectedStateResponse_ResponseStatus value);

  public:
  // @@protoc_insertion_point(class_scope:ServerConnectedStateResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::KexMsg* kex_;
    int status_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pcomserver_2eproto;
};
// -------------------------------------------------------------------

class ClientConnectedStateRequest final : public ::google::protobuf::MessageLite
/* @@protoc_insertion_point(class_definition:ClientConnectedStateRequest) */ {
 public:
  inline ClientConnectedStateRequest() : ClientConnectedStateRequest(nullptr) {}
  ~ClientConnectedStateRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ClientConnectedStateRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ClientConnectedStateRequest(const ClientConnectedStateRequest& from) : ClientConnectedStateRequest(nullptr, from) {}
  inline ClientConnectedStateRequest(ClientConnectedStateRequest&& from) noexcept
      : ClientConnectedStateRequest(nullptr, std::move(from)) {}
  inline ClientConnectedStateRequest& operator=(const ClientConnectedStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConnectedStateRequest& operator=(ClientConnectedStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<std::string>(::google::protobuf::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientConnectedStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConnectedStateRequest* internal_default_instance() {
    return reinterpret_cast<const ClientConnectedStateRequest*>(
        &_ClientConnectedStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ClientConnectedStateRequest& a, ClientConnectedStateRequest& b) { a.Swap(&b); }
  inline void Swap(ClientConnectedStateRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConnectedStateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConnectedStateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::MessageLite::DefaultConstruct<ClientConnectedStateRequest>(arena);
  }
  void CheckTypeAndMergeFrom(
      const ::google::protobuf::MessageLite& from) final;
  void CopyFrom(const ClientConnectedStateRequest& from);
  void MergeFrom(const ClientConnectedStateRequest& from);
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ClientConnectedStateRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "ClientConnectedStateRequest"; }

 protected:
  explicit ClientConnectedStateRequest(::google::protobuf::Arena* arena);
  ClientConnectedStateRequest(::google::protobuf::Arena* arena, const ClientConnectedStateRequest& from);
  ClientConnectedStateRequest(::google::protobuf::Arena* arena, ClientConnectedStateRequest&& from) noexcept
      : ClientConnectedStateRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  // nested types ----------------------------------------------------
  using RequestType = ClientConnectedStateRequest_RequestType;
  static constexpr RequestType UNKNOWN = ClientConnectedStateRequest_RequestType_UNKNOWN;
  static constexpr RequestType REQUEST_KEX = ClientConnectedStateRequest_RequestType_REQUEST_KEX;
  static constexpr RequestType REQUEST_AUTH = ClientConnectedStateRequest_RequestType_REQUEST_AUTH;
  static inline bool RequestType_IsValid(int value) {
    return ClientConnectedStateRequest_RequestType_IsValid(value);
  }
  static constexpr RequestType RequestType_MIN = ClientConnectedStateRequest_RequestType_RequestType_MIN;
  static constexpr RequestType RequestType_MAX = ClientConnectedStateRequest_RequestType_RequestType_MAX;
  static constexpr int RequestType_ARRAYSIZE = ClientConnectedStateRequest_RequestType_RequestType_ARRAYSIZE;
  template <typename T>
  static inline const std::string& RequestType_Name(T value) {
    return ClientConnectedStateRequest_RequestType_Name(value);
  }
  static inline bool RequestType_Parse(absl::string_view name, RequestType* value) {
    return ClientConnectedStateRequest_RequestType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kKexFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .KexMsg kex = 2;
  bool has_kex() const;
  void clear_kex() ;
  const ::KexMsg& kex() const;
  PROTOBUF_NODISCARD ::KexMsg* release_kex();
  ::KexMsg* mutable_kex();
  void set_allocated_kex(::KexMsg* value);
  void unsafe_arena_set_allocated_kex(::KexMsg* value);
  ::KexMsg* unsafe_arena_release_kex();

  private:
  const ::KexMsg& _internal_kex() const;
  ::KexMsg* _internal_mutable_kex();

  public:
  // .ClientConnectedStateRequest.RequestType type = 1;
  void clear_type() ;
  ::ClientConnectedStateRequest_RequestType type() const;
  void set_type(::ClientConnectedStateRequest_RequestType value);

  private:
  ::ClientConnectedStateRequest_RequestType _internal_type() const;
  void _internal_set_type(::ClientConnectedStateRequest_RequestType value);

  public:
  // @@protoc_insertion_point(class_scope:ClientConnectedStateRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::KexMsg* kex_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_pcomserver_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// KexMsg

// .KexMsg.KexAlg alg = 1;
inline void KexMsg::clear_alg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alg_ = 0;
}
inline ::KexMsg_KexAlg KexMsg::alg() const {
  // @@protoc_insertion_point(field_get:KexMsg.alg)
  return _internal_alg();
}
inline void KexMsg::set_alg(::KexMsg_KexAlg value) {
  _internal_set_alg(value);
  // @@protoc_insertion_point(field_set:KexMsg.alg)
}
inline ::KexMsg_KexAlg KexMsg::_internal_alg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::KexMsg_KexAlg>(_impl_.alg_);
}
inline void KexMsg::_internal_set_alg(::KexMsg_KexAlg value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.alg_ = value;
}

// bytes pkey = 2;
inline void KexMsg::clear_pkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkey_.ClearToEmpty();
}
inline const std::string& KexMsg::pkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:KexMsg.pkey)
  return _internal_pkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KexMsg::set_pkey(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:KexMsg.pkey)
}
inline std::string* KexMsg::mutable_pkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pkey();
  // @@protoc_insertion_point(field_mutable:KexMsg.pkey)
  return _s;
}
inline const std::string& KexMsg::_internal_pkey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pkey_.Get();
}
inline void KexMsg::_internal_set_pkey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkey_.Set(value, GetArena());
}
inline std::string* KexMsg::_internal_mutable_pkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.pkey_.Mutable( GetArena());
}
inline std::string* KexMsg::release_pkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:KexMsg.pkey)
  return _impl_.pkey_.Release();
}
inline void KexMsg::set_allocated_pkey(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pkey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pkey_.IsDefault()) {
          _impl_.pkey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:KexMsg.pkey)
}

// -------------------------------------------------------------------

// ClientConnectedStateRequest

// .ClientConnectedStateRequest.RequestType type = 1;
inline void ClientConnectedStateRequest::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::ClientConnectedStateRequest_RequestType ClientConnectedStateRequest::type() const {
  // @@protoc_insertion_point(field_get:ClientConnectedStateRequest.type)
  return _internal_type();
}
inline void ClientConnectedStateRequest::set_type(::ClientConnectedStateRequest_RequestType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:ClientConnectedStateRequest.type)
}
inline ::ClientConnectedStateRequest_RequestType ClientConnectedStateRequest::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ClientConnectedStateRequest_RequestType>(_impl_.type_);
}
inline void ClientConnectedStateRequest::_internal_set_type(::ClientConnectedStateRequest_RequestType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional .KexMsg kex = 2;
inline bool ClientConnectedStateRequest::has_kex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kex_ != nullptr);
  return value;
}
inline void ClientConnectedStateRequest::clear_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kex_ != nullptr) _impl_.kex_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::KexMsg& ClientConnectedStateRequest::_internal_kex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KexMsg* p = _impl_.kex_;
  return p != nullptr ? *p : reinterpret_cast<const ::KexMsg&>(::_KexMsg_default_instance_);
}
inline const ::KexMsg& ClientConnectedStateRequest::kex() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ClientConnectedStateRequest.kex)
  return _internal_kex();
}
inline void ClientConnectedStateRequest::unsafe_arena_set_allocated_kex(::KexMsg* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kex_);
  }
  _impl_.kex_ = reinterpret_cast<::KexMsg*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClientConnectedStateRequest.kex)
}
inline ::KexMsg* ClientConnectedStateRequest::release_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KexMsg* released = _impl_.kex_;
  _impl_.kex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KexMsg* ClientConnectedStateRequest::unsafe_arena_release_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ClientConnectedStateRequest.kex)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KexMsg* temp = _impl_.kex_;
  _impl_.kex_ = nullptr;
  return temp;
}
inline ::KexMsg* ClientConnectedStateRequest::_internal_mutable_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kex_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::KexMsg>(GetArena());
    _impl_.kex_ = reinterpret_cast<::KexMsg*>(p);
  }
  return _impl_.kex_;
}
inline ::KexMsg* ClientConnectedStateRequest::mutable_kex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::KexMsg* _msg = _internal_mutable_kex();
  // @@protoc_insertion_point(field_mutable:ClientConnectedStateRequest.kex)
  return _msg;
}
inline void ClientConnectedStateRequest::set_allocated_kex(::KexMsg* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.kex_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.kex_ = reinterpret_cast<::KexMsg*>(value);
  // @@protoc_insertion_point(field_set_allocated:ClientConnectedStateRequest.kex)
}

// -------------------------------------------------------------------

// ServerConnectedStateResponse

// .ServerConnectedStateResponse.ResponseStatus status = 1;
inline void ServerConnectedStateResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::ServerConnectedStateResponse_ResponseStatus ServerConnectedStateResponse::status() const {
  // @@protoc_insertion_point(field_get:ServerConnectedStateResponse.status)
  return _internal_status();
}
inline void ServerConnectedStateResponse::set_status(::ServerConnectedStateResponse_ResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ServerConnectedStateResponse.status)
}
inline ::ServerConnectedStateResponse_ResponseStatus ServerConnectedStateResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ServerConnectedStateResponse_ResponseStatus>(_impl_.status_);
}
inline void ServerConnectedStateResponse::_internal_set_status(::ServerConnectedStateResponse_ResponseStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// optional .KexMsg kex = 2;
inline bool ServerConnectedStateResponse::has_kex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kex_ != nullptr);
  return value;
}
inline void ServerConnectedStateResponse::clear_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kex_ != nullptr) _impl_.kex_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::KexMsg& ServerConnectedStateResponse::_internal_kex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::KexMsg* p = _impl_.kex_;
  return p != nullptr ? *p : reinterpret_cast<const ::KexMsg&>(::_KexMsg_default_instance_);
}
inline const ::KexMsg& ServerConnectedStateResponse::kex() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerConnectedStateResponse.kex)
  return _internal_kex();
}
inline void ServerConnectedStateResponse::unsafe_arena_set_allocated_kex(::KexMsg* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kex_);
  }
  _impl_.kex_ = reinterpret_cast<::KexMsg*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ServerConnectedStateResponse.kex)
}
inline ::KexMsg* ServerConnectedStateResponse::release_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KexMsg* released = _impl_.kex_;
  _impl_.kex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::KexMsg* ServerConnectedStateResponse::unsafe_arena_release_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ServerConnectedStateResponse.kex)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::KexMsg* temp = _impl_.kex_;
  _impl_.kex_ = nullptr;
  return temp;
}
inline ::KexMsg* ServerConnectedStateResponse::_internal_mutable_kex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kex_ == nullptr) {
    auto* p = ::google::protobuf::MessageLite::DefaultConstruct<::KexMsg>(GetArena());
    _impl_.kex_ = reinterpret_cast<::KexMsg*>(p);
  }
  return _impl_.kex_;
}
inline ::KexMsg* ServerConnectedStateResponse::mutable_kex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::KexMsg* _msg = _internal_mutable_kex();
  // @@protoc_insertion_point(field_mutable:ServerConnectedStateResponse.kex)
  return _msg;
}
inline void ServerConnectedStateResponse::set_allocated_kex(::KexMsg* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.kex_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.kex_ = reinterpret_cast<::KexMsg*>(value);
  // @@protoc_insertion_point(field_set_allocated:ServerConnectedStateResponse.kex)
}

// -------------------------------------------------------------------

// ClientAuthRequest

// .ClientAuthRequest.RequestType request = 1;
inline void ClientAuthRequest::clear_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_ = 0;
}
inline ::ClientAuthRequest_RequestType ClientAuthRequest::request() const {
  // @@protoc_insertion_point(field_get:ClientAuthRequest.request)
  return _internal_request();
}
inline void ClientAuthRequest::set_request(::ClientAuthRequest_RequestType value) {
  _internal_set_request(value);
  // @@protoc_insertion_point(field_set:ClientAuthRequest.request)
}
inline ::ClientAuthRequest_RequestType ClientAuthRequest::_internal_request() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ClientAuthRequest_RequestType>(_impl_.request_);
}
inline void ClientAuthRequest::_internal_set_request(::ClientAuthRequest_RequestType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.request_ = value;
}

// -------------------------------------------------------------------

// ServerAuthResponse

// .ServerAuthResponse.ResponseStatus status = 1;
inline void ServerAuthResponse::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
}
inline ::ServerAuthResponse_ResponseStatus ServerAuthResponse::status() const {
  // @@protoc_insertion_point(field_get:ServerAuthResponse.status)
  return _internal_status();
}
inline void ServerAuthResponse::set_status(::ServerAuthResponse_ResponseStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ServerAuthResponse.status)
}
inline ::ServerAuthResponse_ResponseStatus ServerAuthResponse::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ServerAuthResponse_ResponseStatus>(_impl_.status_);
}
inline void ServerAuthResponse::_internal_set_status(::ServerAuthResponse_ResponseStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// optional string serverInfo = 2;
inline bool ServerAuthResponse::has_serverinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ServerAuthResponse::clear_serverinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.serverinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerAuthResponse::serverinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ServerAuthResponse.serverInfo)
  return _internal_serverinfo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ServerAuthResponse::set_serverinfo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serverinfo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ServerAuthResponse.serverInfo)
}
inline std::string* ServerAuthResponse::mutable_serverinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_serverinfo();
  // @@protoc_insertion_point(field_mutable:ServerAuthResponse.serverInfo)
  return _s;
}
inline const std::string& ServerAuthResponse::_internal_serverinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.serverinfo_.Get();
}
inline void ServerAuthResponse::_internal_set_serverinfo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.serverinfo_.Set(value, GetArena());
}
inline std::string* ServerAuthResponse::_internal_mutable_serverinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.serverinfo_.Mutable( GetArena());
}
inline std::string* ServerAuthResponse::release_serverinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ServerAuthResponse.serverInfo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.serverinfo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serverinfo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ServerAuthResponse::set_allocated_serverinfo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.serverinfo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.serverinfo_.IsDefault()) {
          _impl_.serverinfo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ServerAuthResponse.serverInfo)
}

// repeated .ServerAuthResponse.AuthMethod method = 3;
inline int ServerAuthResponse::_internal_method_size() const {
  return _internal_method().size();
}
inline int ServerAuthResponse::method_size() const {
  return _internal_method_size();
}
inline void ServerAuthResponse::clear_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.method_.Clear();
}
inline ::ServerAuthResponse_AuthMethod ServerAuthResponse::method(int index) const {
  // @@protoc_insertion_point(field_get:ServerAuthResponse.method)
  return static_cast<::ServerAuthResponse_AuthMethod>(_internal_method().Get(index));
}
inline void ServerAuthResponse::set_method(int index, ::ServerAuthResponse_AuthMethod value) {
  _internal_mutable_method()->Set(index, value);
  // @@protoc_insertion_point(field_set:ServerAuthResponse.method)
}
inline void ServerAuthResponse::add_method(::ServerAuthResponse_AuthMethod value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_method()->Add(value);
  // @@protoc_insertion_point(field_add:ServerAuthResponse.method)
}
inline const ::google::protobuf::RepeatedField<int>& ServerAuthResponse::method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ServerAuthResponse.method)
  return _internal_method();
}
inline ::google::protobuf::RepeatedField<int>* ServerAuthResponse::mutable_method()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ServerAuthResponse.method)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_method();
}
inline const ::google::protobuf::RepeatedField<int>& ServerAuthResponse::_internal_method()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.method_;
}
inline ::google::protobuf::RepeatedField<int>* ServerAuthResponse::_internal_mutable_method() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.method_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::KexMsg_KexAlg> : std::true_type {};
template <>
struct is_proto_enum<::ClientConnectedStateRequest_RequestType> : std::true_type {};
template <>
struct is_proto_enum<::ServerConnectedStateResponse_ResponseStatus> : std::true_type {};
template <>
struct is_proto_enum<::ClientAuthRequest_RequestType> : std::true_type {};
template <>
struct is_proto_enum<::ServerAuthResponse_ResponseStatus> : std::true_type {};
template <>
struct is_proto_enum<::ServerAuthResponse_AuthMethod> : std::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_pcomserver_2eproto_2epb_2eh
